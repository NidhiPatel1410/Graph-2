// In this problem, using few arrays to store necessary information. First dividing the nodes into groups based on the edges between
// them by doing dfs. So, colors array will store which group the node belong to. Then, in groups array, storing how many total no
// of nodes in each group. And in total array storing how many infected nodes in each group. Then traversing through the initials 
// array, checking if the number of infected nodes is 1, then making the node as ans. Later when found a node which is able to save
// more number of nodes then replacing it, else if the number of saved is same but the index is lower than replacing.

// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : no
class Solution {
    int[] colors;
    int color;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        // Base case
        if (graph == null || graph.length == 0) {
            return 0;
        }
        int n = graph.length;
        // Colors array which will have group number of each node
        colors = new int[n];
        // Fill it with -1 initially
        Arrays.fill(colors, -1);
        // Take color variable
        color = 0;
        // Loop through colors array
        for (int i = 0; i < n; i++) {
            // If no group is assigned
            if (colors[i] == -1) {
                // Call dfs
                dfs(graph, i);
                // One is group is assigned same color so now after dfs is completed, increment
                // color
                color++;
            }
        }
        // Take groups array for number of nodes in each group
        int[] groups = new int[color];
        // Loop through colors array
        for (int i = 0; i < n; i++) {
            // Get the group
            int group = colors[i];
            // In groups array at that index add 1
            groups[group]++;
        }
        // Total for storing the total infected nodes in each group
        int[] total = new int[color];
        // Loop through initials array
        for (int i = 0; i < initial.length; i++) {
            // Get the group which will be index in totals array
            int index = colors[initial[i]];
            // Add 1 at that index
            total[index]++;
        }
        // Declare ans as -1
        int ans = -1;
        // Loop through initials array
        for (int i = 0; i < initial.length; i++) {
            // Get the group
            int group = colors[initial[i]];
            // Check if only 1 infected node
            if (total[group] == 1) {
                // Ans is not yet found
                if (ans == -1) {
                    // Then assign the current node as ans
                    ans = initial[i];
                }
                // Else if check if the current node is saving more nodes than the node present
                // in ans
                else if (groups[group] > groups[colors[ans]]) {
                    // In that case replace the ans
                    ans = initial[i];
                }
                // Else if check if the nodes saved are same but the current node value is
                // smaller than node present in ans
                else if (groups[group] == groups[colors[ans]] && initial[i] < ans) {
                    // In that case replace
                    ans = initial[i];
                }
            }
        }
        // Now if the ans is still -1, in that case we need to return the lowest node
        int min = Integer.MAX_VALUE;
        if (ans == -1) {
            // Loop through initial
            for (int i = 0; i < initial.length; i++) {
                min = Math.min(min, initial[i]);
                // Store the min in ans
                ans = min;
            }
        }
        // Return ans
        return ans;
    }

    private void dfs(int[][] graph, int index) {
        // Base case if the node is already having a group assigned, return
        if (colors[index] != -1) {
            return;
        }
        // Else assign the color i.e group
        colors[index] = color;
        // Now Run a loop and for all the connected nodes, call dfs and assign same
        // group
        for (int i = 0; i < graph.length; i++) {
            // If the adjacency matrix is having value 1, that means there is a edge or
            // connection
            if (graph[index][i] == 1) {
                // So call dfs
                dfs(graph, i);
            }
        }
    }
}